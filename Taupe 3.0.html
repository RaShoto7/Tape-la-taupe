<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Tape-la-taupe ‚Äî Ultra 3D Enhanced</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --glass: rgba(255,255,255,.14);
  --glass-strong: rgba(255,255,255,.22);
  --border: rgba(255,255,255,.35);
  --text: #ecf0f1;
  --accent: #feca57;
  --danger: #e74c3c;
  --ok: #27ae60;
}
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%}
body{
  font-family:'Fredoka',system-ui; color:var(--text); overflow:hidden;
  background: radial-gradient(1200px 600px at 75% 30%, #214a67 0%, #142837 40%, #0c1822 100%);
  user-select:none; -webkit-user-select:none; touch-action:none;
}
#gameContainer{position:relative;width:100vw;height:100vh; cursor: crosshair;}
#three-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

/* halos + nuages d'accueil */
.bg-halo::before,.bg-halo::after{
  content:""; position:absolute; width:120vmax; height:120vmax; border-radius:50%;
  filter: blur(70px); opacity:.22; z-index:0; animation:orb 28s linear infinite;
}
.bg-halo::before{background:#4ecdc4; left:-25vmax; top:-20vmax}
.bg-halo::after{background:#ff6b6b; right:-30vmax; bottom:-25vmax; animation-duration:36s}
@keyframes orb{from{transform:rotate(0)}to{transform:rotate(360deg)}}
.cloud{ position:absolute; opacity:.2; filter:drop-shadow(0 8px 12px rgba(0,0,0,.25)); z-index:0 }
.cloud svg{ fill:#fff }
.cloud.c1{ left:-160px; top:18%; width:160px; animation:float 42s linear infinite }
.cloud.c2{ left:-120px; top:36%; width:120px; animation:float 55s linear infinite 8s }
.cloud.c3{ left:-240px; top:62%; width:220px; animation:float 48s linear infinite 16s }
@keyframes float{ from{transform:translateX(0)} to{transform:translateX(110vw)} }

/* PANNEAUX / HUD */
.panel{
  background:var(--glass); border:1px solid var(--border); backdrop-filter: blur(14px);
  border-radius:18px; box-shadow:0 20px 40px rgba(0,0,0,.35) inset, 0 8px 24px rgba(0,0,0,.35);
}
.header{ position:absolute; left:20px; right:20px; top:20px; z-index:20; display:flex; align-items:center; justify-content:space-between; padding:12px 16px }
.hud-left{display:flex; gap:12px; align-items:center}
.hud-score{font-weight:700; font-size:20px}
.hud-score b{font-size:26px; color:var(--accent)}
.hud-time{position:absolute; left:50%; transform:translateX(-50%); font-weight:700; font-size:20px}
.hud-time b{font-size:26px}
.hud-time b.low{color:var(--danger)}
.hud-combo{position:absolute; left:50%; transform:translateX(-50%); top:60px; font-weight:700; font-size:18px; color:var(--accent); opacity:0; transition:opacity 0.3s}
.hud-combo.active{opacity:1; animation:pulse 0.5s ease-out}
@keyframes pulse{0%{transform:translateX(-50%) scale(1)}50%{transform:translateX(-50%) scale(1.2)}100%{transform:translateX(-50%) scale(1)}}

/* ACCUEIL */
.menu{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; z-index:10 }
.menu.active{ display:flex }
.title{
  font-family:"Press Start 2P", monospace; font-size: clamp(32px, 6vw, 84px);
  text-align:center; margin-bottom:32px; letter-spacing:4px;
  text-shadow: 0 0 18px rgba(255,255,255,.45), 0 0 50px rgba(78,205,196,.35);
  animation:breath 4s ease-in-out infinite;
}
@keyframes breath{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}

/* Boutons √©pur√©s */
.btn{
  position:relative;
  appearance:none; border:1px solid var(--border); color:#fff; font-weight:700; letter-spacing:1px;
  background:linear-gradient(180deg, var(--glass-strong), rgba(255,255,255,.08));
  padding:16px 42px; border-radius:14px; cursor:pointer; margin:10px auto; font-size:22px;
  box-shadow: 0 10px 26px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
  transition: all .15s ease;
}
.btn:hover{
  background:linear-gradient(180deg, rgba(255,255,255,.25), rgba(255,255,255,.12));
  transform:translateY(-2px);
  box-shadow:0 12px 28px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.15);
}
.btn:active{ transform:translateY(0) scale(.98) }
.btn.small{ font-size:18px; padding:12px 22px }

/* Cartes */
.card{ max-width:820px; padding:28px; margin:16px; text-align:left }
.section-title{font-weight:800; margin:6px 0 10px 0; opacity:.9}

/* Scores */
.list{line-height:1.8}
.stats-grid{display:grid; grid-template-columns: repeat(2, minmax(180px,1fr)); gap:10px}
.stat{padding:10px 12px; border-radius:10px; background:rgba(255,255,255,.10)}

/* Pop points */
.pop{ position:fixed; font-weight:900; font-size:42px; pointer-events:none; animation:pop 1.1s ease-out forwards; text-shadow:0 0 12px rgba(0,0,0,.45); z-index:30 }
@keyframes pop{ from{ transform:translate(-50%,-50%) scale(.7); opacity:1 } to{ transform:translate(-50%,-160%) scale(1.3); opacity:0 } }

/* MUSIQUE: ic√¥ne seule, slider au hover */
.mus{ position:absolute; right:20px; top:20px; z-index:25; display:flex; align-items:center; gap:10px }
.mus .toggle{ width:44px; height:44px; display:grid; place-items:center; border-radius:12px; cursor:pointer; background:rgba(255,255,255,.18); border:1px solid var(--border) }
.mus .slider{ width:160px; opacity:0; pointer-events:none; transition:.2s; background:var(--glass); border:1px solid var(--border); padding:8px 10px; border-radius:12px; backdrop-filter:blur(12px) }
.mus:hover .slider{ opacity:1; pointer-events:auto }
.slider input[type=range]{ width:140px; accent-color:var(--accent) }
.muted{ opacity:.5 }

/* OVER (lisibilit√© des boutons renforc√©e) */
.footer-actions{ display:flex; gap:14px; justify-content:center; margin-top:18px }
.footer-actions .btn{ background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.25)); border-color:rgba(255,255,255,.5) }

/* POPUP D√âTAILS */
.modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:40 }
.modal.active{ display:flex }
.modal .box{ width:min(820px,94vw); background:rgba(0,0,0,.45); border:1px solid var(--border); border-radius:16px; backdrop-filter:blur(12px); padding:20px }
.modal .close{ position:absolute; top:16px; right:16px; cursor:pointer; font-weight:800 }

/* Responsive */
@media (max-width:768px){
  .btn{ font-size:20px; padding:14px 28px }
}
</style>
</head>
<body>
<div id="gameContainer" class="bg-halo">
  <div id="three-canvas"></div>

  <div class="cloud c1"><svg viewBox="0 0 100 60"><path d="M10 60 Q-10 40 15 30 Q5 10 35 20 Q50 0 65 20 Q85 15 85 35 Q115 40 90 55 Z"/></svg></div>
  <div class="cloud c2"><svg viewBox="0 0 100 60"><path d="M10 60 Q-10 40 15 30 Q5 10 35 20 Q50 0 65 20 Q85 15 85 35 Q115 40 90 55 Z"/></svg></div>
  <div class="cloud c3"><svg viewBox="0 0 100 60"><path d="M10 60 Q-10 40 15 30 Q5 10 35 20 Q50 0 65 20 Q85 15 85 35 Q115 40 90 55 Z"/></svg></div>

  <div class="header panel" id="hud" style="display:none">
    <div class="hud-left">
      <div class="hud-score">Score : <b id="score">0</b></div>
    </div>
    <div class="hud-time">Temps : <b id="timer">30</b></div>
    <div class="hud-combo" id="combo">Combo x<span id="comboValue">1</span>!</div>
  </div>

  <div class="mus" id="musicPanel">
    <div class="toggle" id="musicToggle" title="Musique">üéµ</div>
    <div class="slider"><input id="volume" type="range" min="0" max="1" step="0.01" value="0.35" /></div>
  </div>

  <div id="menu" class="menu active">
    <div class="title">Tape-la-taupe !</div>
    <button class="btn" id="playBtn">Solo</button>
    <button class="btn" id="rulesBtn">R√®gles</button>
    <button class="btn" id="scoresBtn">Scores</button>
    <div style="opacity:.45;margin-top:12px;font-family:'Press Start 2P';font-size:12px">Version 4.0 Enhanced</div>
  </div>

  <div id="rules" class="menu">
    <div class="card panel" style="text-align:center">
      <h2>Comment jouer</h2>
      <div style="margin:10px 0">
        üü´ Taupe : <b>+1</b> &nbsp;&nbsp; ‚≠ê Taupe d'or : <b>+5</b> &nbsp;&nbsp; ü¶ä Renard : <b style="color:var(--danger)">‚àí2 & ‚àí3s</b>
      </div>
      <div style="margin:10px 0; font-size:14px; opacity:0.8">
        Encha√Ænez les coups pour des combos multiplicateurs !<br>
        Mode Rush √† 10 secondes restantes !
      </div>
      <div class="footer-actions"><button class="btn small" id="backRules">Retour</button></div>
    </div>
  </div>

  <div id="scores" class="menu">
    <div class="card panel">
      <h2 class="section-title">Derni√®res Parties</h2>
      <div id="scoresList" class="list">Aucune partie</div>

      <h2 class="section-title" style="margin-top:18px">Statistiques</h2>
      <div id="scoresStats" class="stats-grid"></div>

      <div class="footer-actions"><button class="btn small" id="backScores">Retour</button></div>
    </div>
  </div>

  <div id="over" class="menu">
    <div class="card panel" style="text-align:center">
      <h2>Partie termin√©e</h2>
      <div id="finalScore" style="font-size:28px;color:var(--accent);font-weight:700">Score : 0</div>
      <div id="resume" style="margin:12px 0 8px;font-size:16px"></div>
      <div class="footer-actions">
        <button class="btn" id="detailsBtn">D√©tails</button>
        <button class="btn" id="again">Rejouer</button>
        <button class="btn" id="backMenu">Menu</button>
      </div>
    </div>
  </div>

  <div id="detailsModal" class="modal">
    <div class="box panel" style="position:relative">
      <div class="close" id="closeDetails">‚úï</div>
      <h3>Statistiques d√©taill√©es</h3>
      <div id="detailsContent" style="margin-top:8px"></div>
    </div>
  </div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
/* ====== √âTAT & UI ====== */
const ui = {
  menu: document.getElementById('menu'),
  rules: document.getElementById('rules'),
  scores: document.getElementById('scores'),
  over: document.getElementById('over'),
  hud: document.getElementById('hud'),
  score: document.getElementById('score'),
  timer: document.getElementById('timer'),
  combo: document.getElementById('combo'),
  comboValue: document.getElementById('comboValue'),
  list: document.getElementById('scoresList'),
  stats: document.getElementById('scoresStats'),
  final: document.getElementById('finalScore'),
  resume: document.getElementById('resume'),
  vol: document.getElementById('volume'),
  musicBtn: document.getElementById('musicToggle'),
  detailsBtn: document.getElementById('detailsBtn'),
  modal: document.getElementById('detailsModal'),
  details: document.getElementById('detailsContent'),
  closeDetails: document.getElementById('closeDetails'),
  gameContainer: document.getElementById('gameContainer')
};

let scene, camera, renderer;
let holes = [], moles = [], clouds = [], particles = [];
let score = 0, timeLeft = 30, running = false;
let combo = 0, comboTimer = 0, maxCombo = 0;
let clock = new THREE.Clock();
let spawnTimer = 0, rush = false;
let raycaster = new THREE.Raycaster(), pointer = new THREE.Vector2();
const statsRun = { hit:{normal:0,gold:0,fox:0}, seen:{normal:0,gold:0,fox:0}, clicks:0, hits:0, maxCombo:0 };
const CAM = { start:new THREE.Vector3(0, 8, 14), play:new THREE.Vector3(0, 6, 10), t:0, zooming:false };

/* ====== AUDIO ====== */
Tone.Destination.volume.value = -12;
ui.vol.addEventListener('input', ()=>Tone.Destination.volume.value = 20*(+ui.vol.value-1));
function unlockAudio(){
  Tone.start().then(()=>{
    Tone.Transport.start();
    if(homeSeq) homeSeq.mute=false;
    if(gameSeq) gameSeq.mute=true;
  });
  window.removeEventListener('pointerdown', unlockAudio);
}
window.addEventListener('pointerdown', unlockAudio, {once:true});
ui.musicBtn.addEventListener('click', ()=>{
  const m = Tone.Destination.mute = !Tone.Destination.mute;
  ui.musicBtn.classList.toggle('muted', m);
});

// music
const soft = new Tone.AMSynth({
  harmonicity:1.4,
  envelope:{attack:.02,decay:.6,sustain:.25,release:1.2},
  modulationEnvelope:{attack:.1,decay:.4,sustain:.2,release:1.2}
}).toDestination();

const homeSeq = new Tone.Sequence((t,n)=>soft.triggerAttackRelease(n,"1n",t),
  ["C3",["E3","G3"],"A2",["D3","F3"],null,["C3","E3","G3"],"B2",["D3","G3"]], "1m");
const gameSeq = new Tone.Sequence((t,n)=>soft.triggerAttackRelease(n,"8n",t),
  ["G4","E4","C4","E4","A4","G4","E4",null], "4n");
homeSeq.loop = true; gameSeq.loop = true;

// sfx
const sMole = new Tone.Synth({
  oscillator:{type:'triangle'},
  envelope:{attack:0.003,decay:0.12,sustain:0,release:0.05}
}).toDestination();
const sFox = new Tone.Synth({
  oscillator:{type:'square'},
  envelope:{attack:0.003,decay:0.25,sustain:0,release:0.12}
}).toDestination();
sFox.volume.value = -6;
const bell = new Tone.Synth({
  oscillator:{type:'sine'},
  envelope:{attack:0.001,decay:0.35,sustain:0,release:0.25}
}).toDestination();
bell.volume.value = -4;
const metal = new Tone.MetalSynth({
  frequency:250,
  envelope:{attack:0.001,decay:0.25,release:0.15},
  harmonicity:5.1,
  modulationIndex:16,
  resonance:5000,
  octaves:1.2
}).toDestination();
metal.volume.value = -12;

function sparkle(){
  const n=Tone.now();
  bell.triggerAttackRelease("E6","16n",n+0);
  bell.triggerAttackRelease("A6","16n",n+0.06);
  bell.triggerAttackRelease("C7","16n",n+0.12);
  metal.triggerAttackRelease(0.1,"8n",n+0.02);
}

/* ====== THREE ====== */
function init3D(){
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0c1822, 20, 120);

  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
  camera.position.copy(CAM.start);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(1.5, devicePixelRatio));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.getElementById('three-canvas').appendChild(renderer.domElement);

  // lumi√®res
  scene.add(new THREE.AmbientLight(0xffffff, .6));
  const sun = new THREE.DirectionalLight(0xffffff, .85);
  sun.position.set(10,20,10);
  sun.castShadow = true;
  sun.shadow.mapSize.set(512,512);
  sun.shadow.camera.near=0.5;
  sun.shadow.camera.far=60;
  sun.shadow.camera.left=-15;
  sun.shadow.camera.right=15;
  sun.shadow.camera.top=15;
  sun.shadow.camera.bottom=-15;
  scene.add(sun);

  // Sol en forme d'√Æle volante avec relief
  const groundGeo = new THREE.CylinderGeometry(12, 10, 3, 8, 4);
  const verts = groundGeo.attributes.position;

  // Cr√©er un relief irr√©gulier
  for(let i = 0; i < verts.count; i++){
    const x = verts.getX(i);
    const y = verts.getY(i);
    const z = verts.getZ(i);
    const dist = Math.sqrt(x * x + z * z);

    // Ajouter du bruit pour le relief
    if(y > 0) { // Surface sup√©rieure
      verts.setY(i, y + Math.sin(x * 0.5) * 0.3 + Math.cos(z * 0.5) * 0.3 + Math.random() * 0.2);
    }

    // Bords arrondis qui descendent
    if(dist > 8) {
      verts.setY(i, y - (dist - 8) * 0.5);
    }
  }
  groundGeo.computeVertexNormals();

  const groundMat = new THREE.MeshLambertMaterial({
    color: 0x3e9a46,
    side: THREE.DoubleSide
  });

  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.position.y = -1.5;
  ground.receiveShadow = true;
  scene.add(ground);

  // Rochers sur les bords
  const rockGeo = new THREE.DodecahedronGeometry(0.8, 0);
  const rockMat = new THREE.MeshLambertMaterial({ color: 0x5a5a5a });
  for(let i = 0; i < 12; i++){
    const angle = (i / 12) * Math.PI * 2;
    const rock = new THREE.Mesh(rockGeo, rockMat);
    rock.position.set(
      Math.cos(angle) * (9 + Math.random() * 2),
      -1 + Math.random() * 0.5,
      Math.sin(angle) * (9 + Math.random() * 2)
    );
    rock.scale.setScalar(0.5 + Math.random() * 0.5);
    rock.rotation.set(Math.random(), Math.random(), Math.random());
    rock.castShadow = true;
    scene.add(rock);
  }

  grassTufts();
  stones();
  createHoles();
  decorateAround();
  addWoodFrame();
  createClouds();

  window.addEventListener('resize', onResize);

  // Configuration des √©v√©nements de clic
  setupEventListeners();
}

function grassTufts(){
  const geo = new THREE.ConeGeometry(0.12, 0.5, 4);
  const mat = new THREE.MeshLambertMaterial({color: 0x2b7a34});

  for(let i = 0; i < 60; i++){
    const t = new THREE.Mesh(geo, mat);
    const angle = Math.random() * Math.PI * 2;
    const dist = 4 + Math.random() * 4;
    t.position.set(
      Math.cos(angle) * dist,
      0.1,
      Math.sin(angle) * dist
    );
    t.rotation.x = -(Math.PI/2) + (Math.random() * 0.2 - 0.1);
    scene.add(t);
  }
}

function stones(){
  const geo = new THREE.DodecahedronGeometry(0.25, 0);
  const mat = new THREE.MeshLambertMaterial({color: 0x8d8d8d});

  for(let i = 0; i < 20; i++){
    const s = new THREE.Mesh(geo, mat);
    const angle = Math.random() * Math.PI * 2;
    const dist = 3 + Math.random() * 5;
    s.position.set(
      Math.cos(angle) * dist,
      0.05,
      Math.sin(angle) * dist
    );
    s.scale.setScalar(0.5 + Math.random() * 0.5);
    s.castShadow = true;
    scene.add(s);
  }
}

function decorateAround(){
  const g = new THREE.ConeGeometry(0.08, 0.15, 5);
  const m = new THREE.MeshLambertMaterial({color: 0xffdf6e});

  for(let i = 0; i < 40; i++){
    const f = new THREE.Mesh(g, m);
    const angle = Math.random() * Math.PI * 2;
    const dist = 2 + Math.random() * 6;
    f.position.set(
      Math.cos(angle) * dist,
      0.05,
      Math.sin(angle) * dist
    );
    f.rotation.x = -Math.PI/2;
    scene.add(f);
  }
}

function addWoodFrame(){
  const plankGeo = new THREE.BoxGeometry(10, 0.4, 0.5);
  const plankMat = new THREE.MeshLambertMaterial({color: 0x8b5a2b});

  const north = new THREE.Mesh(plankGeo, plankMat);
  north.position.set(0, 0.2, -5.5);
  north.castShadow = true;
  scene.add(north);

  const south = north.clone();
  south.position.z = 5.5;
  scene.add(south);

  const sideGeo = new THREE.BoxGeometry(0.5, 0.4, 10);
  const west = new THREE.Mesh(sideGeo, plankMat);
  west.position.set(-5.5, 0.2, 0);
  west.castShadow = true;
  scene.add(west);

  const east = west.clone();
  east.position.x = 5.5;
  scene.add(east);
}

function createClouds(){
  const sph=new THREE.SphereGeometry(1,8,6), mat=new THREE.MeshLambertMaterial({color:0xffffff,transparent:true,opacity:.8});
  for(let i=0;i<5;i++){
    const cl=new THREE.Group();
    for(let j=0;j<4;j++){
      const p=new THREE.Mesh(sph,mat.clone());
      p.scale.setScalar(1+Math.random());
      p.position.x=j*1.5-2;
      p.position.y=Math.random()*0.5;
      cl.add(p);
    }
    cl.position.set(Math.random()*40-20, 15+Math.random()*5, Math.random()*40-20);
    cl.userData.speed=0.01+Math.random()*0.02;
    clouds.push(cl);
    scene.add(cl);
  }
}

function createHoles(){
  const cylGeo = new THREE.CylinderGeometry(1.3, 1.0, 0.6, 12);
  const cylMat = new THREE.MeshLambertMaterial({color: 0x3a2818});
  const torGeo = new THREE.TorusGeometry(1.3, 0.25, 6, 12);
  const torMat = new THREE.MeshLambertMaterial({color: 0x4a3420});

  const pos = [
    [-3, 0, -3], [0, 0, -3], [3, 0, -3],
    [-3, 0, 0], [0, 0, 0], [3, 0, 0],
    [-3, 0, 3], [0, 0, 3], [3, 0, 3]
  ];

  pos.forEach((p, i) => {
    const hole = new THREE.Mesh(cylGeo, cylMat);
    hole.position.set(p[0], -0.3, p[2]);
    hole.receiveShadow = true;
    scene.add(hole);

    const ring = new THREE.Mesh(torGeo, torMat);
    ring.position.set(p[0], 0.1, p[2]);
    ring.rotation.x = -Math.PI/2;
    ring.castShadow = true;
    scene.add(ring);

    const dirtGeo = new THREE.RingGeometry(1.3, 1.6, 8);
    const dirtMat = new THREE.MeshLambertMaterial({
      color: 0x5a4030,
      side: THREE.DoubleSide
    });
    const dirt = new THREE.Mesh(dirtGeo, dirtMat);
    dirt.position.set(p[0], 0.05, p[2]);
    dirt.rotation.x = -Math.PI/2;
    scene.add(dirt);

    holes.push({
      position: new THREE.Vector3(p[0], 0, p[2]),
      occupied: false,
      index: i
    });
  });
}

/* ====== CR√âATURES R√âALISTES ====== */
const geoBody = new THREE.SphereGeometry(0.9, 12, 10);
const geoHead = new THREE.SphereGeometry(0.7, 10, 8);
const eyeGeo = new THREE.SphereGeometry(0.12, 6, 4);
const earGeo = new THREE.SphereGeometry(0.25, 6, 4);
const noseGeo = new THREE.SphereGeometry(0.15, 6, 4);

const mBrown = new THREE.MeshLambertMaterial({ color: 0x4a3420 });
const mBrownLight = new THREE.MeshLambertMaterial({ color: 0x6b4d35 });
const mGold = new THREE.MeshLambertMaterial({ color: 0xFFD700, emissive: 0xFFAA00, emissiveIntensity: 0.3 });
const mOrange = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
const mBlack = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
const mWhite = new THREE.MeshLambertMaterial({ color: 0xffffff });
const mPink = new THREE.MeshLambertMaterial({ color: 0xFF69B4 });

function creature(type = 'normal') {
  const g = new THREE.Group();
  g.userData.originalY = 0;
  g.userData.creatureType = type;

  const bodyMat = type === 'gold' ? mGold : type === 'fox' ? mOrange : mBrown;
  const body = new THREE.Mesh(geoBody, bodyMat);
  body.position.y = -0.3;
  body.scale.set(1.1, 0.9, 1.1);
  body.castShadow = true;
  g.add(body);

  const headMat = type === 'gold' ? mGold : type === 'fox' ? mOrange : mBrownLight;
  const head = new THREE.Mesh(geoHead, headMat);
  head.position.y = 0.4;
  head.castShadow = true;
  g.add(head);

  const eye1 = new THREE.Mesh(eyeGeo, mBlack);
  eye1.position.set(-0.2, 0.5, 0.55);
  g.add(eye1);

  const eye2 = new THREE.Mesh(eyeGeo, mBlack);
  eye2.position.set(0.2, 0.5, 0.55);
  g.add(eye2);

  const pupil1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 4, 4), mWhite);
  pupil1.position.set(-0.22, 0.52, 0.63);
  g.add(pupil1);

  const pupil2 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 4, 4), mWhite);
  pupil2.position.set(0.18, 0.52, 0.63);
  g.add(pupil2);

  if (type === 'normal') {
    const nose = new THREE.Mesh(noseGeo, mPink);
    nose.position.set(0, 0.35, 0.65);
    nose.scale.set(1.2, 0.8, 0.8);
    g.add(nose);

    const ear1 = new THREE.Mesh(earGeo, mBrown);
    ear1.position.set(-0.35, 0.6, 0);
    ear1.scale.set(1, 0.7, 0.5);
    g.add(ear1);

    const ear2 = new THREE.Mesh(earGeo, mBrown);
    ear2.position.set(0.35, 0.6, 0);
    ear2.scale.set(1, 0.7, 0.5);
    g.add(ear2);

    const clawGeo = new THREE.ConeGeometry(0.08, 0.3, 4);
    const clawMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
    for(let i = -1; i <= 1; i++) {
      const claw = new THREE.Mesh(clawGeo, clawMat);
      claw.position.set(i * 0.15, -0.5, 0.8);
      claw.rotation.x = -0.3;
      g.add(claw);
    }
  }

  if (type === 'gold') {
    const crownGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.2, 8);
    const crown = new THREE.Mesh(crownGeo, mGold);
    crown.position.y = 0.85;
    g.add(crown);

    const gemGeo = new THREE.OctahedronGeometry(0.08, 0);
    const gemMat = new THREE.MeshBasicMaterial({ color: 0xFF1493 });
    for(let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2;
      const gem = new THREE.Mesh(gemGeo, gemMat);
      gem.position.set(Math.cos(angle) * 0.32, 0.9, Math.sin(angle) * 0.32);
      g.add(gem);
    }

    const nose = new THREE.Mesh(noseGeo, mGold);
    nose.position.set(0, 0.35, 0.65);
    g.add(nose);
  }

  if (type === 'fox') {
    const snoutGeo = new THREE.ConeGeometry(0.2, 0.5, 6);
    const snout = new THREE.Mesh(snoutGeo, mOrange);
    snout.position.set(0, 0.3, 0.7);
    snout.rotation.x = 1.57;
    g.add(snout);

    const foxNose = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 4), mBlack);
    foxNose.position.set(0, 0.3, 0.95);
    g.add(foxNose);

    const foxEarGeo = new THREE.ConeGeometry(0.2, 0.4, 4);
    const ear1 = new THREE.Mesh(foxEarGeo, mOrange);
    ear1.position.set(-0.3, 0.75, -0.1);
    g.add(ear1);

    const ear2 = new THREE.Mesh(foxEarGeo, mOrange);
    ear2.position.set(0.3, 0.75, -0.1);
    g.add(ear2);

    const tailGeo = new THREE.ConeGeometry(0.25, 0.8, 6);
    const tail = new THREE.Mesh(tailGeo, mOrange);
    tail.position.set(0, -0.4, -0.5);
    tail.rotation.x = -2.5;
    tail.scale.set(0.7, 1, 0.5);
    g.add(tail);
  }

  g.castShadow = true;
  g.receiveShadow = true;
  return g;
}

/* ====== SYST√àME DE PARTICULES D'IMPACT ====== */
function createImpactParticles(position, color){
  const particleCount = 8;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const velocities = [];

  for(let i = 0; i < particleCount; i++){
    positions[i * 3] = position.x;
    positions[i * 3 + 1] = position.y + 1;
    positions[i * 3 + 2] = position.z;

    velocities.push(new THREE.Vector3(
      (Math.random() - 0.5) * 0.3,
      Math.random() * 0.3 + 0.1,
      (Math.random() - 0.5) * 0.3
    ));
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

  const material = new THREE.PointsMaterial({
    color: color,
    size: 0.3,
    transparent: true,
    opacity: 1
  });

  const particleSystem = new THREE.Points(geometry, material);
  particleSystem.userData = { velocities, life: 0.6 };
  scene.add(particleSystem);
  particles.push(particleSystem);
}

/* ====== GAME LOGIC ====== */
function spawn(){
  if(!running) return;
  const free=holes.filter(h=>!h.occupied);
  if(!free.length) return;

  const slot=free[(Math.random()*free.length)|0];
  slot.occupied=true;

  let type='normal';
  const r=Math.random();
  if(r<0.15) type='gold';
  else if(r<0.35) type='fox';

  statsRun.seen[type]++;

  const m=creature(type);
  m.position.copy(slot.position);
  m.position.y=-2;

  m.userData={
    type: type,
    points: type==='gold' ? 5 : type==='fox' ? -2 : 1,
    isUp: false,
    down: false,
    holeIndex: slot.index,
    age: 0,
    hit: false,
    targetY: 0.5 + Math.random() * 0.3,
    isMole: true
  };

  scene.add(m);
  moles.push(m);
}

function tickCreatures(dt){
  for(let i=moles.length-1;i>=0;i--){
    const m=moles[i];

    if(!m.userData.isUp){
      m.position.y += 0.18;
      if(m.position.y >= m.userData.targetY){
        m.userData.isUp=true;
        m.userData.originalY = m.position.y;
      }
    }
    else if(m.userData.down){
      m.position.y -= 0.25;
      if(m.position.y <= -2){
        const h=holes[m.userData.holeIndex];
        if(h) h.occupied=false;
        scene.remove(m);
        moles.splice(i,1);
      }
    }
    else{
      m.userData.age += dt;

      if(m.userData.isUp && !m.userData.down){
        m.position.y = m.userData.originalY + Math.sin(Date.now() * 0.003) * 0.05;
      }

      const stay = (timeLeft <= 10 ? 0.5 : 0.8) + Math.random() * 0.4;
      if(m.userData.age >= stay) m.userData.down = true;
    }

    if(m.userData.type === 'gold'){
      m.rotation.y += 0.05;
    }
  }
}

/* ====== SYST√àME DE CLIC CORRIG√â ====== */
function setupEventListeners(){
  // MODIFICATION : On √©coute les clics sur le conteneur principal, c'est plus fiable.
  ui.gameContainer.addEventListener('click', onPointerClick);
  ui.gameContainer.addEventListener('touchstart', onTouchStart);
}

function onPointerClick(event){
  if(!running) return;

  // MODIFICATION : On calcule les coordonn√©es par rapport au conteneur.
  const rect = ui.gameContainer.getBoundingClientRect();
  pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  processHit();
}

function onTouchStart(event){
  if(!running) return;
  event.preventDefault();

  const touch = event.touches[0];
  // MODIFICATION : On calcule les coordonn√©es par rapport au conteneur.
  const rect = ui.gameContainer.getBoundingClientRect();
  pointer.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

  processHit();
}

function processHit() {
    statsRun.clicks++;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObjects(moles, true);

    if (intersects.length > 0) {
        let hitObject = intersects[0].object;

        // On remonte au parent (le groupe) pour avoir la cr√©ature enti√®re.
        while (hitObject.parent && !hitObject.userData.isMole) {
            hitObject = hitObject.parent;
        }

        // On v√©rifie si la cr√©ature est bien une cible valide qu'on peut taper.
        if (hitObject.userData.isMole && hitObject.userData.isUp && !hitObject.userData.down && !hitObject.userData.hit) {
            hitMole(hitObject);
        }
    }
}

function hitMole(mole){
  if(mole.userData.hit) return;

  mole.userData.hit = true;
  mole.userData.down = true;

  const type = mole.userData.type;
  statsRun.hits++;

  // Gestion du combo
  comboTimer = 2;

  let points = 0;
  let message = '';
  let color = '';

  if(type === 'fox'){
    combo = 0;
    points = -2;
    score = Math.max(0, score + points);
    timeLeft = Math.max(0, timeLeft - 3);
    statsRun.hit.fox++;
    message = '‚àí2 & ‚àí3s';
    color = '#e74c3c';
    sFox.triggerAttackRelease("C2", "4n");
    ui.combo.classList.remove('active');
  }
  else if(type === 'gold'){
    combo++;
    points = 5;
    if(combo > 3) points = 6;
    if(combo > 6) points = 8;
    score += points;
    statsRun.hit.gold++;
    message = '+' + points;
    color = '#FFD700';
    sparkle();
    shakeCamera(0.1);
  }
  else {
    combo++;
    points = 1;
    if(combo > 5) points = 2;
    if(combo > 10) points = 3;
    score += points;
    statsRun.hit.normal++;
    message = '+' + points;
    color = '#27ae60';
    sMole.triggerAttackRelease("E5", "32n");
  }

  // Affichage
  showPoints(mole.position, message, color);
  createImpactParticles(mole.position, color.replace('#', '0x'));

  // Mise √† jour UI
  ui.score.textContent = score;
  ui.timer.innerHTML = timeLeft <= 10 ? `<b class="low">${timeLeft}</b>` : `<b>${timeLeft}</b>`;

  if(combo > 1){
    ui.combo.classList.add('active');
    ui.comboValue.textContent = combo;
  }

  if(combo > maxCombo) maxCombo = combo;
  if(combo > statsRun.maxCombo) statsRun.maxCombo = combo;
}

function showPoints(position, text, color){
  const pos2D = position.clone();
  pos2D.y += 2;
  pos2D.project(camera);

  const x = (pos2D.x * 0.5 + 0.5) * window.innerWidth;
  const y = (-pos2D.y * 0.5 + 0.5) * window.innerHeight;

  const div = document.createElement('div');
  div.className = 'pop';
  div.style.left = x + 'px';
  div.style.top = y + 'px';
  div.style.color = color;
  div.textContent = text;

  document.body.appendChild(div);
  setTimeout(() => div.remove(), 1100);
}

function shakeCamera(intensity){
  if(intensity < 0.05) return;
  const originalPos = camera.position.clone();
  let shakeCount = 0;
  const shake = setInterval(() => {
    camera.position.x = originalPos.x + (Math.random() - 0.5) * intensity;
    camera.position.y = originalPos.y + (Math.random() - 0.5) * intensity;
    intensity *= 0.85;
    shakeCount++;
    if(shakeCount > 5 || intensity < 0.01){
      clearInterval(shake);
      camera.position.copy(originalPos);
    }
  }, 30);
}

/* ====== LOOP ====== */
let secAcc = 0;
function loop(){
  const dt = clock.getDelta();

  if(running){
    secAcc += dt;
    while(secAcc >= 1){
      secAcc -= 1;
      timeLeft--;
      ui.timer.innerHTML = timeLeft <= 10 ? `<b class="low">${timeLeft}</b>` : `<b>${timeLeft}</b>`;
      if(timeLeft <= 0) end();
    }

    if(comboTimer > 0){
      comboTimer -= dt;
      if(comboTimer <= 0){
        combo = 0;
        ui.combo.classList.remove('active');
      }
    }

    spawnTimer += dt;
    let base = Math.max(0.22, (0.75 - score * 0.012));
    if(timeLeft <= 10) base /= 3;
    if(spawnTimer >= base){
      spawnTimer = 0;
      spawn();
    }

    tickCreatures(dt);

    if(timeLeft <= 10 && !rush){
      clouds.forEach(c => c.userData.speed *= 1.6);
      rush = true;
      scene.fog.color.setHex(0x1a0808);
    }
  }

  if(CAM.zooming){
    CAM.t = Math.min(1, CAM.t + 0.03);
    camera.position.lerpVectors(CAM.start, CAM.play, CAM.t);
  }

  clouds.forEach(c => {
    c.position.x += c.userData.speed;
    if(c.position.x > 25) c.position.x = -25;
  });

  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    if(p.userData && p.userData.velocities){
      const positions = p.geometry.attributes.position;
      p.userData.life -= 0.04;

      if(p.userData.life <= 0){
        scene.remove(p);
        p.geometry.dispose();
        p.material.dispose();
        particles.splice(i, 1);
        continue;
      }

      p.material.opacity = p.userData.life;

      for(let j = 0; j < p.userData.velocities.length; j++){
        const v = p.userData.velocities[j];
        positions.setY(j, positions.getY(j) + v.y);
        v.y -= 0.02;
      }
      positions.needsUpdate = true;
    }
  }

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}

/* ====== MENUS / SCORE ====== */
function show(el){
  [ui.menu, ui.rules, ui.scores, ui.over].forEach(e => e.style.display = 'none');
  if(el) el.style.display = 'flex';
}

function resetRun(){
  statsRun.hit.normal = 0;
  statsRun.hit.gold = 0;
  statsRun.hit.fox = 0;
  statsRun.seen.normal = 0;
  statsRun.seen.gold = 0;
  statsRun.seen.fox = 0;
  statsRun.clicks = 0;
  statsRun.hits = 0;
  statsRun.maxCombo = 0;
  combo = 0;
  maxCombo = 0;
  comboTimer = 0;
}

function start(){
  moles.forEach(m => scene.remove(m));
  moles = [];
  holes.forEach(h => h.occupied = false);

  resetRun();
  running = true;
  rush = false;
  score = 0;
  timeLeft = 30;
  spawnTimer = 0;
  secAcc = 0;

  ui.score.textContent = '0';
  ui.timer.textContent = '30';
  ui.combo.classList.remove('active');
  ui.hud.style.display = 'flex';
  show(null);

  CAM.t = 0;
  CAM.zooming = true;

  scene.fog.color.setHex(0x0c1822);

  homeSeq.mute = true;
  gameSeq.mute = false;
  Tone.Transport.bpm.value = 100;
}

function end(){
  running = false;
  ui.hud.style.display = 'none';
  CAM.zooming = false;

  saveScore();
  renderEnd();
  show(ui.over);

  gameSeq.mute = true;
  homeSeq.mute = false;
  Tone.Transport.bpm.value = 60;
}

function saveScore(){
  const arr = JSON.parse(localStorage.getItem('ultra3dScores') || '[]');
  arr.push({
    s: score,
    t: Date.now(),
    hit: statsRun.hit,
    seen: statsRun.seen,
    clicks: statsRun.clicks,
    hits: statsRun.hits,
    maxCombo: statsRun.maxCombo
  });
  localStorage.setItem('ultra3dScores', JSON.stringify(arr.slice(-50)));
}

function renderScores(){
  const arr = (JSON.parse(localStorage.getItem('ultra3dScores') || '[]')).slice(-10).reverse();
  ui.list.innerHTML = arr.length ?
    arr.map((e,i) => `#${i+1} ‚Äî <b>${e.s} pts</b> (Combo: ${e.maxCombo || 0})`).join('<br>') :
    'Aucune partie';

  if(!arr.length){
    ui.stats.innerHTML = '<div class="stat">Pas de donn√©es</div>';
    return;
  }

  const n = arr.length;
  const avg = (x) => (x/n).toFixed(1);
  const sum = arr.reduce((a,e) => {
    a.score += e.s;
    a.clicks += e.clicks || 0;
    a.hits += e.hits || 0;
    a.hn += (e.hit?.normal || 0);
    a.hg += (e.hit?.gold || 0);
    a.hf += (e.hit?.fox || 0);
    a.sn += (e.seen?.normal || 0);
    a.sg += (e.seen?.gold || 0);
    a.sf += (e.seen?.fox || 0);
    a.maxCombo = Math.max(a.maxCombo, e.maxCombo || 0);
    return a;
  }, {score:0, clicks:0, hits:0, hn:0, hg:0, hf:0, sn:0, sg:0, sf:0, maxCombo:0});

  const acc = sum.clicks ? Math.round(100 * sum.hits / sum.clicks) : 0;
  const r = (h,s) => s ? Math.round(100 * h / s) : 0;

  ui.stats.innerHTML = `
    <div class="stat">Score moyen : <b>${avg(sum.score)}</b></div>
    <div class="stat">Pr√©cision moyenne : <b>${acc}%</b></div>
    <div class="stat">Taupes : <b>${sum.hn}</b> / ${sum.sn} (${r(sum.hn,sum.sn)}%)</div>
    <div class="stat">Taupes d'or : <b>${sum.hg}</b> / ${sum.sg} (${r(sum.hg,sum.sg)}%)</div>
    <div class="stat">Renards touch√©s : <b>${sum.hf}</b> / ${sum.sf}</div>
    <div class="stat">Meilleur combo : <b>${sum.maxCombo}</b></div>
  `;
}

function renderEnd(){
  ui.final.textContent = 'Score : ' + score;
  const acc = statsRun.clicks ? Math.round(100 * statsRun.hits / statsRun.clicks) : 0;
  ui.resume.innerHTML = `
    Pr√©cision <b>${acc}%</b> ‚Ä¢
    Taupes <b>${statsRun.hit.normal}</b> ‚Ä¢
    Or <b>${statsRun.hit.gold}</b> ‚Ä¢
    Renards <b>${statsRun.hit.fox}</b> ‚Ä¢
    Combo max <b>${statsRun.maxCombo}</b>
  `;

  const ratio = (h,s) => s ? Math.round(100 * h / s) : 0;
  ui.details.innerHTML = `
    <div style="line-height:1.8">
      <strong>Apparitions :</strong><br>
      Taupes: <b>${statsRun.seen.normal}</b>, Or: <b>${statsRun.seen.gold}</b>, Renards: <b>${statsRun.seen.fox}</b><br><br>
      <strong>Performance :</strong><br>
      Taupes touch√©es: <b>${statsRun.hit.normal}</b> (<b>${ratio(statsRun.hit.normal,statsRun.seen.normal)}%</b>)<br>
      Or touch√©s: <b>${statsRun.hit.gold}</b> (<b>${ratio(statsRun.hit.gold,statsRun.seen.gold)}%</b>)<br>
      Renards touch√©s: <b>${statsRun.hit.fox}</b> / <b>${statsRun.seen.fox}</b><br>
      Combo maximum: <b>${statsRun.maxCombo}</b>
    </div>
  `;
}

/* ====== EVENTS ====== */
document.getElementById('playBtn').onclick = () => start();
document.getElementById('rulesBtn').onclick = () => show(ui.rules);
document.getElementById('scoresBtn').onclick = () => { renderScores(); show(ui.scores); };
document.getElementById('backRules').onclick = () => show(ui.menu);
document.getElementById('backScores').onclick = () => show(ui.menu);
document.getElementById('again').onclick = () => start();
document.getElementById('backMenu').onclick = () => show(ui.menu);
ui.detailsBtn.onclick = () => ui.modal.classList.add('active');
ui.closeDetails.onclick = () => ui.modal.classList.remove('active');

function onResize(){
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

/* ====== START ====== */
init3D();
show(ui.menu);
homeSeq.mute = false;
gameSeq.mute = true;
Tone.Transport.bpm.value = 60;
requestAnimationFrame(loop);
</script>
</body>
</html>
